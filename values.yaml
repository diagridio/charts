#------------------------------------------------------------------------------
# Global Options
#------------------------------------------------------------------------------
global:
  # Override the name of the chart
  nameOverride: "catalyst"
  # Override the full name of the chart+release
  fullnameOverride: ""
  image:
    # Global image pull policy for all container images in the chart
    # Can be overridden by individual image pullPolicy
    pullPolicy: Always
    # Global list of secret names for image pull secrets across all pod specs
    # Secrets must exist in the same namespace
    # Reference: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    imagePullSecrets: []
    # Global registry for all container images in the chart
    registry: ""

  # Global labels applied to all resources deployed by the chart
  labels: {}


#------------------------------------------------------------------------------
# Shared Configurations
#------------------------------------------------------------------------------
shared:
  resources:
    limits:
      cpu: "500m"
      memory: "512Mi"
    requests:
      cpu: "250m"
      memory: "256Mi"

  nodeSelector: {}

  tolerations: []

  affinity: {}


#------------------------------------------------------------------------------
# Agent Configurations
#------------------------------------------------------------------------------
agent:
  logLevel: info

  config:
    host:
      id: ""
      region_id: ""
      region_metadata:
        display_name: ""
        cloud_provider: ""
      ingress_ip_addr: ""
      egress_addresses: []
    control_plane_url: ""
    inspection:
      enabled: false
    placement:
      max_project_count: 15
    project:
      dns_top_level_domain: ""
      ingress_tls_secret_name: ""
      default_workflow: namespace
      enable_scheduler_service: false
      dapr_hot_reloading: false
      sidecar_capture_init_errors: false
      redis_kafka_cache:
        enabled: false
    sidecar:
      image_tag: 'edge'
    api_token_error:
      image_tag: 'edge'
    otel:
      enabled: true
      # TODO: change to public registry?
      image_repository: ""
      image_tag: 'edge'
      metrics_endpoint: https://metrics.local.diagrid.io:443/api/v1/push
      metrics_tls_insecure: true
      internal_cortex_enabled: false
      internal_cortex_endpoint: ""
      internal_cortex_org_id: common
      loki_enabled: false
      loki_endpoint: https://logs.local.diagrid.io:443/loki/api/v1/push
      loki_tls_insecure: true
      logs_resources:
        limits:
          memory: 500Mi
        requests:
          cpu: 50m
          memory: 500Mi
      metrics_resources:
        limits:
          memory: 1100Mi
        requests:
          cpu: 75m
          memory: 250Mi
    tls:
      enabled: true
      existingSecretName: "tls"
      mutual: true
      root:
        certFilename: "ca.crt"
      issuer:
        certFilename: "tls.crt"
        keyFilename: "tls.key"
    upstream_dapr:
      # images wil be pulled from a dockerhub proxy so we don't hit ratelimits
      # TODO: change to public registry?
      container_registry: ""
    internal_dapr:
      # TODO: change to public registry?
      container_registry: ""
      sentry_resources:
        limits:
          memory: 100Mi
      scheduler_resources:
        limits:
          memory: 175Mi
        requests:
          memory: 130Mi
      scheduler:
        storage_class: standard
        storage_size: 8Gi
    artifacts:
      # make sure the k0s container image version works with the vcluster chart version when updating these, best is to copy the container image version from the vcluster release
      vcluster_k0s_chart_version: "0.15.2"
      # TODO: change to public registry?
      vcluster_k0s_container_image: ""
      # TODO: change to public registry?
      core_dns_container_image: ""
      internal_registry_username: ""
      internal_registry_password: ""
    kubernetes:
      qps: 25
      burst: 10
    denylist:
      enabled: false

  # secrets config for integrating with a secret provider
  secrets:
    provider: inmemory
    redis:
      host: ""
      password: ""
    aws:
      region: ""

  metrics:
    port: 9090

  replicaCount: 1

  image:
    # TODO: change to public registry?
    registry: ""
    name: cra-agent
    # using single quotes so the script set_helm_version updates this value to the release version
    tag: 'edge'
    fullName: ""
    pullPolicy: Always

  imagePullSecrets: []
  nameOverride: ""
  fullnameOverride: ""

  service:
    type: ClusterIP
    port: 9090

  serviceAccount:
      # Annotations to add to the service account
      annotations: {}
      # The name of the service account to use.
      # If not set and create is true, a name is generated using the fullname template
      name: ""

  podAnnotations:
    prometheus.io/port: "9090"
    prometheus.io/scrape: "true"
    
  podSecurityContext: {}
    # fsGroup: 2000

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  resources:
    limits:
      memory: 1200Mi
    requests:
      cpu: 40m
      memory: 100Mi

  nodeSelector: {}

  tolerations: []

  affinity: {}

  # Golang Soft Memory Limit via env var GOMEMLIMIT
  goSoftLimit:
    percent: 90
  #  override: 600MiB  # it will set GOMEMLIMIT to this value. Supported suffixes, if not using a straight bytes number, are B, KiB, MiB, GiB, and TiB.

  extraEnvs: []

  merge: {}
  patch: {}


#------------------------------------------------------------------------------
# Management Service Configurations
#------------------------------------------------------------------------------
management:
  logLevel: info

  config:
    grpc_server:
      enabled: true
      port: 9090
      request_timeout: 30s
      tls:
        enabled: false
        cacert: "ca.crt"
        issuercert: "tls.crt"
        issuerkey: "tls.key"
        mutual: false
        existingSecretName: ""
    host:
      id: ""
      region_id: ""
      region_metadata:
        cloud_provider: ""
        cloud_provider_region: ""
        display_name: ""
    profiling:
      enabled: false

  # secrets config for integrating with a secret provider
  secrets:
    # NOTE dont run inmemory provider with replicaCount=2
    provider: inmemory
    redis:
      host: ""
      username: ""
      password: ""
    aws:
      region: ""

  # NOTE dont run inmemory provider with replicaCount=2
  replicaCount: 1

  image:
    registry: ""
    name: catalyst-management
    tag: 'edge'
    pullPolicy: Always

  imagePullSecrets: []
  nameOverride: ""
  fullnameOverride: ""

  service:
    type: ClusterIP
    port: 9090

  ingress:
    enabled: false
    dns_top_level_domain: ""

  serviceAccount:
      # Annotations to add to the service account
      annotations: {}
      # The name of the service account to use.
      # If not set and create is true, a name is generated using the fullname template
      name: ""

  podAnnotations:
    prometheus.io/port: "9091"
    prometheus.io/scrape: "true"
    
  podSecurityContext: {}
    # fsGroup: 2000

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  resources:
    limits:
      memory: 1200Mi
    requests:
      cpu: 40m
      memory: 100Mi

  nodeSelector: {}

  tolerations: []

  affinity: {}

  # Golang Soft Memory Limit via env var GOMEMLIMIT
  goSoftLimit:
    percent: 90
  #  override: 600MiB  # it will set GOMEMLIMIT to this value. Supported suffixes, if not using a straight bytes number, are B, KiB, MiB, GiB, and TiB.

  extraEnvs: []

  sentry:
    enabled: false

  merge: {}
  patch: {}


#------------------------------------------------------------------------------
# API_TOKEN_ERROR Configurations
#------------------------------------------------------------------------------
apiTokenError:
  enabled: true
  replicaCount: 1
  
  image:
    registry: ""
    name: cra-agent
    tag: edge
    # optional full name of the container image to use
    fullName: ""
    pullPolicy: Always
  
  imagePullSecrets: []
  nameOverride: "api-token-error"
  fullnameOverride: ""
  
  podAnnotations: {}
  
  podSecurityContext: {}
    # fsGroup: 2000
  
  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000
  
  service:
    type: ClusterIP
  
  resources: {}
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi
  
  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 100
    targetCPUUtilizationPercentage: 80
    # targetMemoryUtilizationPercentage: 80
  
  nodeSelector: {}
  
  tolerations: []
  
  affinity: {}

  merge: {}
  patch: {}



#------------------------------------------------------------------------------
# Contour/Envoy Configurations - Optional
#------------------------------------------------------------------------------
contour:
  enabled: false
  envoy:
    kind: "deployment"
    podAnnotations:
      prometheus.io/port: '8002'
      prometheus.io/envoyscrape: 'true'
    service:
      loadBalancerIP: ""
      annotations:
          service.beta.kubernetes.io/aws-load-balancer-proxy-protocol: '*'
          service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout: '600'
    autoscaling:
      enabled: true
      minReplicas: 2
      behavior:
        scaleDown:
          stabilizationWindowSeconds: 300
          policies:
            - type: Percent
              value: 25
              periodSeconds: 120
        scaleUp:
          stabilizationWindowSeconds: 120
          policies:
            - type: Pods
              value: 1
              periodSeconds: 60
  
    podAntiAffinityPreset: soft
  
    # resources settings for the envoy proxies deployed
    resources:
      requests:
        cpu: "500m"
        memory: "1.5Gi"
  
    priorityClassName: "system-cluster-critical"
  
  contour:
    podAnnotations:
      prometheus.io/port: '8000'
      prometheus.io/scrape: 'true'
    replicaCount: 2
    resources:
      requests:
        cpu: "1"
        memory: "2Gi"
    extraArgs:
      - --use-proxy-protocol
  
    priorityClassName: "system-cluster-critical"
  
  configInline:
    accesslog-format: envoy
    disablePermitInsecure: false
    tls:
      fallback-certificate: { }
    rateLimitService:
      extensionService: contour/ratelimitext
      domain: contour
      enableXRateLimitHeaders: true
      # true - will allow requests to pass even if there's an issue with RLS
      # false - will block the request if there's an issue with RLS
      failOpen: true
    timeouts:
      connection-idle-timeout: 10m
      stream-idle-timeout: 1h
      max-connection-duration: 6h

#------------------------------------------------------------------------------
# Metrics Server Configurations - Optional
#------------------------------------------------------------------------------
metricsServer:
  enabled: false
  replicas: 2
  podDisruptionBudget:
    enabled: true
    minAvailable: 1
  updateStrategy:
    rollingUpdate:
      maxUnavailable: 1
  affinity:
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchLabels:
            app.kubernetes.io/name: metrics-server
            app.kubernetes.io/instance: metrics-server
        namespaces:
        - metrics-server
        topologyKey: kubernetes.io/hostname
  resources:
    requests:
      cpu: 50m
      memory: 100Mi
